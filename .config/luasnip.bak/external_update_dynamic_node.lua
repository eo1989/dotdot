local ls = require('luasnip')
local node_util = require('luasnip.nodes.util')
local util = require('luasnip.util.util')
local opts = { noremap = true, silent = true }

local function find_dynamic_node(node)
  -- the dynamicNode-key is set on snippets generated by a dynamicNode only (its'
  -- actual use is to refer to the dynamicNode that generated the snippet).
  while not node.dynamicNode do
    node = node.parent
    -- if not node then return end
  end
  return node.dynamicNode
end

local external_update_id = 0
-- func_index to update the dynamicNode with different functions.
function dynamic_node_external_update(func_index)
  -- most of this function is about restoring the cursor to the correct
  -- position+mode, the important part are the few lines from
  -- `dynamic_node.snip:store()`.

  -- find current node and the innermost dynamicNode it is inside.
  local current_node = ls.session.current_nodes[vim.api.nvim_get_current_buf()]
  local dynamic_node = find_dynamic_node(current_node)

  -- if not dynamic_node then return end

  -- to identify current node in new snippet, if it is available.
  external_update_id = external_update_id + 1
  current_node.external_update_id = external_update_id
  local current_node_key = current_node.key

  -- store which mode we're in to restore later.
  local insert_pre_call = vim.fn.mode() == 'i'
  -- is byte-indexed! Doesn't matter here, but important to be aware of.
  local cursor_pos_pre_relative = util.pos_sub(util.get_cursor_0ind(), current_node.mark:get_endpoint(1))

  -- leave current generated snippet.
  -- node_util.leave_nodes_between(dynamic_node.snip, current_node)
  node_util.refocus(current_node, dynamic_node.snip)

  -- call update-function.
  local func = dynamic_node.user_args[func_index]
  if func then
    -- the same snippet passed to the dynamicNode-function. Any output from func
    -- should be stored in it under some unused key.
    func(dynamic_node.parent.snippet)
  end

  -- last_args is used to store the last args that were used to generate the
  -- snippet. If this function is called, these will most probably not have
  -- changed, so they are set to nil, which will force an update.
  dynamic_node.last_args = nil
  dynamic_node:update()

  -- everything below here isn't strictly necessary, but it's pretty nice to have.

  -- try to find the node we marked earlier, or a node with the same key.
  -- Both are getting equal priority here, it might make sense to give "exact
  -- same node" higher priority by doing two searches (but that would require
  -- two searches :( )
  local target_node = dynamic_node:find_node(
    function(test_node)
      return (test_node.external_update_id == external_update_id)
        or (current_node_key ~= nil and test_node.key == current_node_key)
    end,
    { find_in_child_snippets = true }
  )

  if target_node then
    -- the node that the cursor was in when changeChoice was called exists
    -- in the active choice! Enter it and all nodes between it and this choiceNode,
    -- then set the cursor.
    -- no_move=true, we move the cursor later on.
    -- node_util.enter_nodes_between(dynamic_node, target_node)
    node_util.refocus(dynamic_node, target_node)

    if insert_pre_call then
      -- set from end, since the most-likely scenario is a user typing at
      -- the end of an insertNode, and in that case, inserting text
      -- before the typed text will probably not result in unexpected
      -- shifts of the cursor.
      util.set_cursor_0ind(util.pos_add(target_node.mark:get_endpoint(1), cursor_pos_pre_relative))
    else
      node_util.select_node(target_node)
    end
    -- set the new current node correctly.
    ls.session.current_nodes[vim.api.nvim_get_current_buf()] = target_node
  else
    -- the marked node wasn't found, just jump into the new snippet noremally.
    ls.session.current_nodes[vim.api.nvim_get_current_buf()] = dynamic_node.snip:jump_into(1)
  end
end

map('i', '<C-f>', function()
  -- local ls = require('luasnip')
  if ls.in_snippet() then
    if ls.choice_active() then
      return ls.change_choice(1)
    else
      return _G.dynamic_node_external_update(1)
    end
  end
end, opts)

map('s', '<C-f>', function()
  -- local ls = require('luasnip')
  if ls.in_snippet() then
    if ls.choice_active() then
      return ls.change_choice(1)
    else
      return _G.dynamic_node_external_update(1)
    end
  end
end, opts)

map('i', '<C-d>', function()
  -- local ls = require('luasnip')
  if ls.in_snippet() then
    if ls.choice_active() then
      return ls.change_choice(-1)
    else
      return _G.dynamic_node_external_update(2)
    end
  end
end, opts)

map('s', '<C-d>', function()
  -- local ls = require('luasnip')
  if ls.in_snippet() then
    if ls.choice_active() then
      return ls.change_choice(-1)
    else
      return _G.dynamic_node_external_update(2)
    end
  end
end, opts)

-- map(
--   'i',
--   '<M-t>',
--   '<cmd>lua require("plugs.luasnip.external_update_dynamic_node").dynamic_node_external_update(1)<Cr>',
--   { noremap = true }
-- )
-- map(
--   's',
--   '<M-t>',
--   '<cmd>lua require("plugs.luasnip.external_update_dynamic_node").dynamic_node_external_update(1)<Cr>',
--   { noremap = true }
-- )
-- map(
--   'i',
--   '<M-s-t>',
--   '<cmd>lua require("plugs.luasnip.external_update_dynamic_node").dynamic_node_external_update(2)<Cr>',
--   { noremap = true }
-- )
-- map(
--   's',
--   '<M-s-t>',
--   '<cmd>lua require("plugs.luasnip.external_update_dynamic_node").dynamic_node_external_update(2)<Cr>',
--   { noremap = true }
-- )
-- map(
--   'i',
--   '<C-g>',
--   '<cmd>lua require("plugs.luasnip.external_update_dynamic_node").dynamic_node_external_update(3)<Cr>',
--   { noremap = true }
-- )
-- map(
--   's',
--   '<C-g>',
--   '<cmd>lua require("plugs.luasnip.external_update_dynamic_node").dynamic_node_external_update(3)<Cr>',
--   { noremap = true }
-- )
-- map(
--   'i',
--   '<C-M-g>',
--   '<cmd>lua require("plugs.luasnip.external_update_dynamic_node").dynamic_node_external_update(4)<Cr>',
--   { noremap = true }
-- )
-- map(
--   's',
--   '<C-M-g>',
--   '<cmd>lua require("plugs.luasnip.external_update_dynamic_node").dynamic_node_external_update(4)<Cr>',
--   { noremap = true }
-- )

return {
  dynamic_node_external_update = dynamic_node_external_update,
}
